{"meta":{"title":"Schrock000's Blog","subtitle":null,"description":null,"author":null,"url":"http://yoursite.com"},"pages":[],"posts":[{"title":"ARM处理器内部寄存器","slug":"ARM内部处理寄存器","date":"2019-10-13T23:26:11.000Z","updated":"2019-10-13T23:49:09.711Z","comments":true,"path":"2019/10/14/ARM内部处理寄存器/","link":"","permalink":"http://yoursite.com/2019/10/14/ARM内部处理寄存器/","excerpt":"","text":"ARM处理器内部寄存器作用 r0-r15 and R0-R15a1-a4 (argument, result, or scratch registers, synonyms for r0 to r3)v1-v8 (variable registers, r4 to r11)sb and SB (static base, r9)ip and IP (intra-procedure-call scratch register, r12)sp and SP (stack pointer, r13)lr and LR (link register, r14)pc and PC (program counter, r15) r0-r3用作传入函数参数，传出函数返回值。在子程序调用之间，可以将 r0-r3 用于任何用途。被调用函数在返回之前不必恢复 r0-r3。如果调用函数需要再次使用 r0-r3 的内容，则它必须保留这些内容。 r4-r11被用来存放函数的局部变量。如果被调用函数使用了这些寄存器，它在返回之前必须恢复这些寄存器的值。 r12是内部调用暂时寄存器 ip。它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色。在过程调用之间，可以将它用于任何用途。被调用函数在返回之前不必恢复 r12。 r13是栈指针 sp。它不能用于任何其它用途。sp 中存放的值在退出被调用函数时必须与进入时的值相同。 r14是链接寄存器 lr。如果您保存了返回地址，则可以在调用之间将 r14 用于其它用途，程序返回时要恢复。 r15是程序计数器 PC。它不能用于任何其它用途。 注意：在中断程序中，所有的寄存器都必须保护，编译器会自动保护R4～R11原文出处：https://blog.csdn.net/wh8_2011/article/details/53195320https://blog.csdn.net/Decisiveness/article/details/44106197","categories":[],"tags":[]},{"title":"Use GCC to build STM32 projects","slug":"Use-GCC-to-build-STM32-projects","date":"2019-02-01T07:31:00.000Z","updated":"2019-02-01T21:02:43.000Z","comments":true,"path":"2019/02/01/Use-GCC-to-build-STM32-projects/","link":"","permalink":"http://yoursite.com/2019/02/01/Use-GCC-to-build-STM32-projects/","excerpt":"","text":"最近突然想建立一个利用makefile编译的STM32工程模板，记录一下辛酸的过程。。。 其实Makefile虽然我不是很熟，但是写一个简单的makefile还是OK的，所以在makefile阶段并没有遇到什么奇怪的问题，注意好makefile的规则就排除了，比如有时候没注意看TAB之类的，然后就是文件的路径。 在make的过程中出现以下报错信息。 12345/tmp/cc6kleCZ.s: Assembler messages:/tmp/cc6kleCZ.s:488: Error: registers may not be the same -- `strexb r0,r0,[r1]&apos;/tmp/cc6kleCZ.s:512: Error: registers may not be the same -- `strexh r0,r0,[r1]&apos;makefile:60: recipe for target &apos;core/CM3/core_cm3.o&apos; failedmake: *** [core/CM3/core_cm3.o] Error 1 作为一个菜鸡，看到Assembler 之类的error是比较慌的，但是还是不能畏惧的，正面刚。打开了core_cm3.c，找到了与它相关的函数，google后发现github上有人解决了，于是看了一下分析，做出了修改。然后成功编译过这一步。 12345678910 uint32_t __STREXB(uint8_t value, uint8_t *addr)&#123; uint32_t result=0; //__ASM volatile (&quot;strexb %0, %2, [%1]&quot; : &quot;=r&quot; (result) : &quot;r&quot; (addr), &quot;r&quot; (value) ); __ASM volatile (&quot;strexb %0, %2, [%1]&quot; : &quot;=&amp;r&quot; (result) : &quot;r&quot; (addr), &quot;r&quot; (value) ); return(result);&#125; 12345678910 uint32_t __STREXH(uint16_t value, uint16_t *addr)&#123; uint32_t result=0; //__ASM volatile (&quot;strexh %0, %2, [%1]&quot; : &quot;=r&quot; (result) : &quot;r&quot; (addr), &quot;r&quot; (value) ); __ASM volatile (&quot;strexh %0, %2, [%1]&quot; : &quot;=&amp;r&quot; (result) : &quot;r&quot; (addr), &quot;r&quot; (value) ); return(result);&#125; 然后还有一个问题就是GCC编译一个文件时出现 12 error: expected &apos;(&apos; before &apos;void&apos;__asm void MSR_MSP(u32 addr) 之类的报错，这个打开源文件后发现其实是GCC在C语言内嵌汇编需要注意的一个地方，修改为如下即可。 123456 void MSR_MSP(u32 addr)&#123; __ASM volatile(&quot;MSR MSP, r0&quot;); __ASM volatile(&quot;BX r14&quot;); &#125; 还有要注意的就是，在stm32 标准固件库内，CORE的startup中有多个文件夹，Keil使用的启动文件在arm文件夹内，这和使用GCC时是不一样的，GCC下应该使用gcc_ride7中的启动文件,TrueSTUDIO是官方的IDE软件，其使用的也是GCC所以也可以使用其中的。然后就是链接文件(.ld)，可以使用stm32标准固件库文件夹下/Project/STM32F10x_StdPeriph_Template/TrueSTUDIO/中的链接文件。 然后成功make出了 hex bin elf等文件，download到stm32后也是正常的。","categories":[],"tags":[]},{"title":"Hello World","slug":"Hello-World","date":"2019-01-01T02:22:00.000Z","updated":"2019-01-01T02:37:24.000Z","comments":true,"path":"2019/01/01/Hello-World/","link":"","permalink":"http://yoursite.com/2019/01/01/Hello-World/","excerpt":"","text":"Hello World1$ Hello World","categories":[],"tags":[]}]}