{"meta":{"title":"Schrock000's Blog","subtitle":null,"description":null,"author":null,"url":"http://yoursite.com"},"pages":[],"posts":[{"title":"STM32H743移植IAR及使用DAPLINK调试配置","slug":"TM32H743移植IAR及使用DAPLINK调试配置","date":"2020-08-10T16:19:00.000Z","updated":"2020-08-10T17:58:42.691Z","comments":true,"path":"2020/08/11/TM32H743移植IAR及使用DAPLINK调试配置/","link":"","permalink":"http://yoursite.com/2020/08/11/TM32H743移植IAR及使用DAPLINK调试配置/","excerpt":"","text":"环境：1、正点原子APOLLO STM32H743开发板2、IAR for ARM 8.323、DAPLINK仿真器4、HAL库版本 STM32Cube_FW_H7_V1.6.0 本人平时用IAR不多，最近觉得它挺香的，于是打算准备一些基于IAR的stm32的模板。然后手头有DAPLINK，就决定是它作为debugger了，方便的功能香得鼻子都流血。由MDK移植到IAR的过程遇到一些问题，在这里记录一下大致的过程。 建立工程以及复制文件就不一一说明了，主要分两部分说几个地方： 1、文件不能全部由MDK的工程中拷贝过来，有些文件需要去官方HAL库的固件包中复制IAR环境需要的文件：1STM32Cube_FW_H7_V1.6.0\\Drivers\\CMSIS\\Device\\ST\\STM32H7xx\\Source\\Templates\\iar目录下的linker文件夹以及*.s文件 我为了以后方便其他型号的MCU使用，把上述目录的相关文件都拷贝了，如果不需要，可以只拷贝需要的型号。MDK和IAR都需要.s文件，只不过两者适用对象不同，所以要拷贝适用于当前环境的。然后特地需要拷贝的linker文件夹中，有若干个.icf文件，这个其实就是MDK环境下的.sct文件（链接器控制文件，也叫分散加载文件），主要描述MCU的FLASH以及RAM情况，外部的SRAM/SDRAM也可以在里面进行概述。 我在工程根目录下建立了startup文件夹用于存放这些文件，因为后面会修改并使用stm32h743xx_flash.icf这个文件，我将其从linker文件夹拷贝到了startup目录中。修改的目的是为了适配开发板，以及内存管理的文件，修改如下： 12345678910111213141516define memory mem with size = 4G;define region ROM_region = mem:[from __ICFEDIT_region_ROM_start__ to __ICFEDIT_region_ROM_end__];define region RAM_region = mem:[from __ICFEDIT_region_RAM_start__ to __ICFEDIT_region_RAM_end__];define region ITCMRAM_region = mem:[from __ICFEDIT_region_ITCMRAM_start__ to __ICFEDIT_region_ITCMRAM_end__];在下方添加define region AXI_RAM_region = mem:[from 0x24000000 to 0x2407FFFF];define region SRAM12_region = mem:[from 0x30000000 to 0x3003FFFF];define region SRAM3_region = mem:[from 0x30040000 to 0x30047FFF];define region SRAM4_region = mem:[from 0x38000000 to 0x3800FFFF];define region EXTRAM_region = mem:[from 0xC0000000 to 0xC1FFFFFF];place in AXI_RAM_region &#123;section .AXI_RAM&#125;;place in SRAM12_region &#123;section .SRAM12&#125;;place in SRAM3_region &#123;section .SRAM3&#125;;place in SRAM4_region &#123;section .SRAM4&#125;;place in EXTRAM_region &#123;section .EXTRAM&#125;; 在正点原子的例程中，原子哥有一个malloc.c文件，用于内存管理，我们也将其移植过来。修改如下：12345678910111213141516171819202122232425262728293031323334353637383940414243#if defined(__CC_ARM) || defined(__GNUC__) //GCC 与 MDK//内存池(64字节对齐)__align(64) u8 mem1base[MEM1_MAX_SIZE]; //内部SRAM内存池__align(64) u8 mem2base[MEM2_MAX_SIZE] __attribute__((at(0XC01F4000))); //外部SDRAM内存池,前面2M给LTDC用了(1280*800*2)__align(64) u8 mem3base[MEM3_MAX_SIZE] __attribute__((at(0x30000000))); //内部SRAM1+SRAM2内存池__align(64) u8 mem4base[MEM4_MAX_SIZE] __attribute__((at(0x38000000))); //内部SRAM4内存池//内存管理表u32 mem1mapbase[MEM1_ALLOC_TABLE_SIZE]; //内部SRAM内存池MAPu32 mem2mapbase[MEM2_ALLOC_TABLE_SIZE] __attribute__((at(0XC01F4000+MEM2_MAX_SIZE))); //外部SDRAM内存池MAPu32 mem3mapbase[MEM3_ALLOC_TABLE_SIZE] __attribute__((at(0x30000000+MEM3_MAX_SIZE))); //内部SRAM1+SRAM2内存池MAPu32 mem4mapbase[MEM4_ALLOC_TABLE_SIZE] __attribute__((at(0x38000000+MEM4_MAX_SIZE))); //内部SRAM4内存池MAP#elif defined(__ICCARM__)#pragma pack(64) //64字节对齐#pragma location=&quot;.AXI_RAM&quot;__no_init u8 mem1base[MEM1_MAX_SIZE];#pragma location=0xC01F4000__no_init u8 mem2base[MEM2_MAX_SIZE];#pragma location=&quot;.SRAM12&quot;__no_init u8 mem3base[MEM3_MAX_SIZE];#pragma location=&quot;.SRAM4&quot;__no_init u8 mem4base[MEM4_MAX_SIZE];#pragma pack()#pragma location=(0x24000000+MEM1_MAX_SIZE)__no_init u32 mem1mapbase[MEM1_ALLOC_TABLE_SIZE]; #pragma location=(0xC01F4000+MEM2_MAX_SIZE)__no_init u32 mem2mapbase[MEM2_ALLOC_TABLE_SIZE]; #pragma location=(0x30000000+MEM3_MAX_SIZE)__no_init u32 mem3mapbase[MEM3_ALLOC_TABLE_SIZE]; #pragma location=(0x38000000+MEM4_MAX_SIZE)__no_init u32 mem4mapbase[MEM4_ALLOC_TABLE_SIZE];#endif 其中的 #pragma pack(64)以及#pragma location网上有详细功能描述及用法介绍，这里不再赘述了。并且其中的__no_init必须添加，否则无法正常使用，在调用my_mem_init()初始化内存池时会失败。 我添加了DSP库，在IAR中预处理宏定义：123456STM32H743xxUSE_HAL_DRIVER__ICCARM__ARM_MATH_CM7ARM_MATH_MATRIX_CHECKARM_MATH_ROUNDING 剩下就是一些日常遇到的error和warning了，我就不说了。 2、在使用DAPLINK的时候，按照一般设置，如下面一文中描述的设置：https://www.eemaker.com/daplink-iar.html我发现STM32H743IITx在只有官方的EVAL板，于是就添加了它，但是发现事情并没有这么简单，程序能下进去，但是它报错，并且不能调试，很难受。1error while calling macro execUserFlashExit 就是这个报错，google之，没发现解决方案，然后查询了IAR_EWARM_user_manual这本手册，以及了解了一波.board/.mac/.flash/.out文件的关系之后，进行了修改，不报错了，调试也正常。 据我了解到的，这些文件负责Flash-loader部分，.board/.flash文件应该都是脚本文件，.board用于指明不同的.flash文件来获取不同的地址映射，.flash用于描述地址映射、如何读写flash的二进制算法文件.out，.mac文件用于寄存器的一些初始化操作。 大致过程是，先调用.board文件，获取不同.flash的地址映射，使用对应的flash读写算法(.out文件)，同时获取.mac文件中要进行的初始化操作。各种信息收集全了之后，就进行flash的烧写了。 由于只有官方的EVAL板，所以通过查看这几个相关文件之间的调用关系，有如下操作：12345678910111213141516拷贝\\IAR Systems\\Embedded Workbench 8.2\\arm\\config\\flashloader\\ST目录下的FlashSTM32H7xx_STM32H743I-EVAL.boardFlashSTM32H7xxx.macFlashSTM32H753_BANK1.flashFlashSTM32H753_BANK2.flashFlashSTM32H7xxx_512kB.out5个文件到工程目录下新建的flashload文件夹中，并分别改名为FlashSTM32H7xx_STM32H743IIT6_APOLLO.boardFlashSTM32H7xxx_APOLLO.macFlashSTM32H743_BANK1_APOLLO.flashFlashSTM32H743_BANK2_APOLLO.flashFlashSTM32H7xxx_512kB.out 修改其中的调用关系，以及.mac文件中的execUserFlashExit()相关内容，这里就是报错的源头。 123456.mac文件中修改此处execUserFlashExit()&#123; __writeMemory32(0x05FA0004, 0xE000ED0C, &quot;Memory&quot;); //perform a soft reset&#125; 然后在IAR设置中选择好修改过的文件，进行调试。","categories":[{"name":"STM32","slug":"STM32","permalink":"http://yoursite.com/categories/STM32/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://yoursite.com/tags/STM32/"},{"name":"IAR","slug":"IAR","permalink":"http://yoursite.com/tags/IAR/"},{"name":"DAPLINK","slug":"DAPLINK","permalink":"http://yoursite.com/tags/DAPLINK/"}]},{"title":"RK3399内核编译以安装docker","slug":"RK3399内核编译以安装docker","date":"2019-10-15T19:14:00.000Z","updated":"2019-10-16T18:18:02.473Z","comments":true,"path":"2019/10/16/RK3399内核编译以安装docker/","link":"","permalink":"http://yoursite.com/2019/10/16/RK3399内核编译以安装docker/","excerpt":"","text":"环境：1、firefly-rk3399开发板2、ubuntu18.04 官方镜像3、内核版本 4.4.154 最近想使用Docker的某容器，在RK3399-firefly上安装的时候报错，具体安装过程就网上随意能搜到的，就不提及了。经过查看各种资料之后，成功安装docker，希望能帮到有需要的各位，也顺便记录一下。大致过程如下： 1、 查看docker的状态发现是failed，journalctl -fu docker 查看日志，有driver not support等字样，具体记不清了，这里大致了解了一下是因为docker有那么几种支持的storage-driver， 恰好内核又没打开任何一个支持的FS，所以只好去编译内核了。 2、修改配置进入linux-sdk/kernel目录下，获取https://raw.githubusercontent.com/docker/docker/master/contrib/check-config.sh脚本查看docker需要的设置是否打开，其他的都是enable，我仅放出storage-driver的配置，主要是要打开overlay的FS.123456789101112131415- Storage Drivers: - &quot;aufs&quot;: - CONFIG_AUFS_FS: missing - &quot;btrfs&quot;: - CONFIG_BTRFS_FS: missing - CONFIG_BTRFS_FS_POSIX_ACL: missing - &quot;devicemapper&quot;: - CONFIG_BLK_DEV_DM: enabled - CONFIG_DM_THIN_PROVISIONING: enabled - &quot;overlay&quot;: - CONFIG_OVERLAY_FS: enabled - &quot;zfs&quot;: - /dev/zfs: missing - zfs command: missing - zpool command: missing 3、之前的配置都是通过make menuconfig配置的，具体怎么操作网上找，挺多的。进入linux-sdk/kernel/目录，make ARCH=arm64 rk3399-firefly-linux.img -j8 编译生成boot.img后烧录到开发板。上电发现docker仍报错，修改配置文件内容（没有就新建），/etc/docker/daemon.json， 内容如下：1234&#123; &quot;registry-mirrors&quot;: [&quot;aliyun加速地址&quot;], &quot;storage-driver&quot;: &quot;overlay&quot;&#125; 上面的阿里云加速地址换成自己的，这里主要是为了pull容器的时候舒服一点，教程可以在网上搜到很多，保存。重启服务：systemctl daemon-reload &amp;&amp; systemctl restart docker还是无法正常运行，继续查看日志，发现报错已经变更了，这时候提示的是iptables does not exist 等字样的信息，其实就是说iptables内核模块没有，配置完编译新内核上传。加入以下模块，基本都在networking support-&gt;networking options中，我也记不太清了，各位自己查找一下吧。。。。 Netfilter connection tracking supportNetbios name service protocal support(new)Netfilter Xtables support (required for ip_tables) IP: Netfilter ConfigurationIPv4 connection tracking support (require for NAT)IP tables support (required for filtering/masq/NAT) 什么 NAT的选项，忘了MASQUERADE target supportREDIRECT target support 按上面步骤重新编译并烧录到开发板，这次上电，docker绿了，开心。操作了一下，正常1234sudo docker run ubuntu:18.04 /bin/echo &quot;Hello world&quot;Status: Downloaded newer image for ubuntu:18.04 Hello world","categories":[{"name":"ARM_Linux","slug":"ARM-Linux","permalink":"http://yoursite.com/categories/ARM-Linux/"}],"tags":[]},{"title":"ARM处理器内部寄存器","slug":"ARM内部处理寄存器","date":"2019-10-13T23:26:11.000Z","updated":"2019-10-16T18:18:02.471Z","comments":true,"path":"2019/10/14/ARM内部处理寄存器/","link":"","permalink":"http://yoursite.com/2019/10/14/ARM内部处理寄存器/","excerpt":"","text":"ARM处理器内部寄存器作用 r0-r15 and R0-R15a1-a4 (argument, result, or scratch registers, synonyms for r0 to r3)v1-v8 (variable registers, r4 to r11)sb and SB (static base, r9)ip and IP (intra-procedure-call scratch register, r12)sp and SP (stack pointer, r13)lr and LR (link register, r14)pc and PC (program counter, r15) r0-r3用作传入函数参数，传出函数返回值。在子程序调用之间，可以将 r0-r3 用于任何用途。被调用函数在返回之前不必恢复 r0-r3。如果调用函数需要再次使用 r0-r3 的内容，则它必须保留这些内容。 r4-r11被用来存放函数的局部变量。如果被调用函数使用了这些寄存器，它在返回之前必须恢复这些寄存器的值。 r12是内部调用暂时寄存器 ip。它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色。在过程调用之间，可以将它用于任何用途。被调用函数在返回之前不必恢复 r12。 r13是栈指针 sp。它不能用于任何其它用途。sp 中存放的值在退出被调用函数时必须与进入时的值相同。 r14是链接寄存器 lr。如果您保存了返回地址，则可以在调用之间将 r14 用于其它用途，程序返回时要恢复。 r15是程序计数器 PC。它不能用于任何其它用途。 注意：在中断程序中，所有的寄存器都必须保护，编译器会自动保护R4～R11原文出处：https://blog.csdn.net/wh8_2011/article/details/53195320https://blog.csdn.net/Decisiveness/article/details/44106197","categories":[],"tags":[]},{"title":"Use GCC to build STM32 projects","slug":"Use-GCC-to-build-STM32-projects","date":"2019-02-01T07:31:00.000Z","updated":"2019-10-16T18:18:02.474Z","comments":true,"path":"2019/02/01/Use-GCC-to-build-STM32-projects/","link":"","permalink":"http://yoursite.com/2019/02/01/Use-GCC-to-build-STM32-projects/","excerpt":"","text":"最近突然想建立一个利用makefile编译的STM32工程模板，记录一下辛酸的过程。。。 其实Makefile虽然我不是很熟，但是写一个简单的makefile还是OK的，所以在makefile阶段并没有遇到什么奇怪的问题，注意好makefile的规则就排除了，比如有时候没注意看TAB之类的，然后就是文件的路径。 在make的过程中出现以下报错信息。 12345/tmp/cc6kleCZ.s: Assembler messages:/tmp/cc6kleCZ.s:488: Error: registers may not be the same -- `strexb r0,r0,[r1]&apos;/tmp/cc6kleCZ.s:512: Error: registers may not be the same -- `strexh r0,r0,[r1]&apos;makefile:60: recipe for target &apos;core/CM3/core_cm3.o&apos; failedmake: *** [core/CM3/core_cm3.o] Error 1 作为一个菜鸡，看到Assembler 之类的error是比较慌的，但是还是不能畏惧的，正面刚。打开了core_cm3.c，找到了与它相关的函数，google后发现github上有人解决了，于是看了一下分析，做出了修改。然后成功编译过这一步。 12345678910 uint32_t __STREXB(uint8_t value, uint8_t *addr)&#123; uint32_t result=0; //__ASM volatile (&quot;strexb %0, %2, [%1]&quot; : &quot;=r&quot; (result) : &quot;r&quot; (addr), &quot;r&quot; (value) ); __ASM volatile (&quot;strexb %0, %2, [%1]&quot; : &quot;=&amp;r&quot; (result) : &quot;r&quot; (addr), &quot;r&quot; (value) ); return(result);&#125; 12345678910 uint32_t __STREXH(uint16_t value, uint16_t *addr)&#123; uint32_t result=0; //__ASM volatile (&quot;strexh %0, %2, [%1]&quot; : &quot;=r&quot; (result) : &quot;r&quot; (addr), &quot;r&quot; (value) ); __ASM volatile (&quot;strexh %0, %2, [%1]&quot; : &quot;=&amp;r&quot; (result) : &quot;r&quot; (addr), &quot;r&quot; (value) ); return(result);&#125; 然后还有一个问题就是GCC编译一个文件时出现 12 error: expected &apos;(&apos; before &apos;void&apos;__asm void MSR_MSP(u32 addr) 之类的报错，这个打开源文件后发现其实是GCC在C语言内嵌汇编需要注意的一个地方，修改为如下即可。 123456 void MSR_MSP(u32 addr)&#123; __ASM volatile(&quot;MSR MSP, r0&quot;); __ASM volatile(&quot;BX r14&quot;); &#125; 还有要注意的就是，在stm32 标准固件库内，CORE的startup中有多个文件夹，Keil使用的启动文件在arm文件夹内，这和使用GCC时是不一样的，GCC下应该使用gcc_ride7中的启动文件,TrueSTUDIO是官方的IDE软件，其使用的也是GCC所以也可以使用其中的。然后就是链接文件(.ld)，可以使用stm32标准固件库文件夹下/Project/STM32F10x_StdPeriph_Template/TrueSTUDIO/中的链接文件。 然后成功make出了 hex bin elf等文件，download到stm32后也是正常的。","categories":[],"tags":[]},{"title":"Hello World","slug":"Hello-World","date":"2019-01-01T02:22:00.000Z","updated":"2019-10-16T18:18:02.472Z","comments":true,"path":"2019/01/01/Hello-World/","link":"","permalink":"http://yoursite.com/2019/01/01/Hello-World/","excerpt":"","text":"Hello World1$ Hello World","categories":[],"tags":[]}]}