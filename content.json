{"meta":{"title":"Schrock000's Blog","subtitle":null,"description":null,"author":null,"url":"http://yoursite.com"},"pages":[{"title":"404","date":"2019-03-02T05:00:00.000Z","updated":"2020-08-10T18:51:37.560Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""}],"posts":[{"title":"Windows下PIP换源","slug":"indows下PIP换源","date":"2021-06-12T14:45:00.000Z","updated":"2021-06-12T15:05:28.856Z","comments":true,"path":"2021/06/12/indows下PIP换源/","link":"","permalink":"http://yoursite.com/2021/06/12/indows下PIP换源/","excerpt":"","text":"windows下pip换aliyun源 最近用pip，已经换了清华的源，不知道为什么还是感觉很慢，还经常报超时错错误，所以决定换个其他的源，在此记录一下。 在资源管理器地址栏输入%appdata%回车，找到pip文件夹，修改pip.ini内容为如下并保存，下次使用pip就会用aliyun的源了，感觉速度快乐起来了。 1234[global]timeout = 6000index-url = https://mirrors.aliyun.com/pypi/simple/trusted-host = mirrors.aliyun.com","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"pip python","slug":"pip-python","permalink":"http://yoursite.com/tags/pip-python/"}]},{"title":"STM32使用GCC编译器内存管理.lds文件处理","slug":"M32使用GCC编译器内存管理-lds文件处理","date":"2020-08-16T15:37:00.000Z","updated":"2020-08-16T15:55:01.012Z","comments":true,"path":"2020/08/16/M32使用GCC编译器内存管理-lds文件处理/","link":"","permalink":"http://yoursite.com/2020/08/16/M32使用GCC编译器内存管理-lds文件处理/","excerpt":"","text":"环境：1、正点原子STM32H743开发板2、VS2017+VisualGDB+STM32CubeMX 使用vs2017+VisualGDB+STM32CubeMX进行开发，原子哥的malloc.c内存管理文件GCC下需要修改.lds文件，文件相关说明不再赘述，这里简单记录一下自己的修改。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215ENTRY(Reset_Handler)MEMORY&#123; FLASH (RX) : ORIGIN = 0x08000000, LENGTH = 2M DTCMRAM (RWX) : ORIGIN = 0x20000000, LENGTH = 128K RAM_D1 (RWX) : ORIGIN = 0x24000000, LENGTH = 512K RAM_D2 (RWX) : ORIGIN = 0x30000000, LENGTH = 288K RAM_D3 (RWX) : ORIGIN = 0x38000000, LENGTH = 64K LCD_RAM (RWX) : ORIGIN = 0xC0000000, LENGTH = 2M EXTRAM (RWX) : ORIGIN = 0xC01F4000, LENGTH = 28912K RAM_D1_TABLE (RWX) : ORIGIN = 0x24064000, LENGTH = 7K RAM_D2_TABLE (RWX) : ORIGIN = 0x3003C000, LENGTH = 1K RAM_D3_TABLE (RWX) : ORIGIN = 0x3800F000, LENGTH = 64K EXTRAM_TABLE (RWX) : ORIGIN = 0xC1E30000, LENGTH = 452K ITCMRAM (RWX) : ORIGIN = 0x00000000, LENGTH = 64K&#125;_estack = 0x20020000;SECTIONS&#123; .isr_vector : &#123; . = ALIGN(4); KEEP(*(.isr_vector)) . = ALIGN(4); &#125; &gt; FLASH .text : &#123; . = ALIGN(4); _stext = .; *(.text) *(.text*) *(.rodata) *(.rodata*) *(.glue_7) *(.glue_7t) KEEP(*(.init)) KEEP(*(.fini)) . = ALIGN(4); _etext = .; &#125; &gt; FLASH .ARM.extab : &#123; . = ALIGN(4); *(.ARM.extab) *(.gnu.linkonce.armextab.*) . = ALIGN(4); &#125; &gt; FLASH .exidx : &#123; . = ALIGN(4); PROVIDE(__exidx_start = .); *(.ARM.exidx*) . = ALIGN(4); PROVIDE(__exidx_end = .); &#125; &gt; FLASH .ARM.attributes : &#123; *(.ARM.attributes) &#125; &gt; FLASH .preinit_array : &#123; PROVIDE(__preinit_array_start = .); KEEP(*(.preinit_array*)) PROVIDE(__preinit_array_end = .); &#125; &gt; FLASH .init_array : &#123; PROVIDE(__init_array_start = .); KEEP(*(SORT(.init_array.*))) KEEP(*(.init_array*)) PROVIDE(__init_array_end = .); &#125; &gt; FLASH .fini_array : &#123; PROVIDE(__fini_array_start = .); KEEP(*(.fini_array*)) KEEP(*(SORT(.fini_array.*))) PROVIDE(__fini_array_end = .); &#125; &gt; FLASH .data : &#123; . = ALIGN(4); _sdata = .; PROVIDE(__data_start__ = _sdata); *(.data) *(.data*) . = ALIGN(4); _edata = .; PROVIDE(__data_end__ = _edata); &#125; &gt; DTCMRAM AT &gt;FLASH _sidata = LOADADDR(.data); .bss : &#123; . = ALIGN(4); _sbss = .; PROVIDE(__bss_start__ = _sbss); *(.bss) *(.bss*) *(COMMON) . = ALIGN(4); _ebss = .; PROVIDE(__bss_end__ = _ebss); &#125; &gt; DTCMRAM PROVIDE(end = .); .heap (NOLOAD) : &#123; . = ALIGN(4); PROVIDE(__heap_start__ = .); KEEP(*(.heap)) . = ALIGN(4); PROVIDE(__heap_end__ = .); &#125; &gt; DTCMRAM .reserved_for_stack (NOLOAD) : &#123; . = ALIGN(4); PROVIDE(__reserved_for_stack_start__ = .); KEEP(*(.reserved_for_stack)) . = ALIGN(4); PROVIDE(__reserved_for_stack_end__ = .); &#125; &gt; DTCMRAM .RAM_D1 0x24000000 (NOLOAD): &#123; . = ALIGN(4); *(.RAM_D1) *(.RAM_D1*) . = ALIGN(4); &#125; AT &gt;RAM_D1 .RAM_D2 0x30000000 (NOLOAD): &#123; . = ALIGN(4); *(.RAM_D2) *(.RAM_D2*) . = ALIGN(4); &#125; AT &gt;RAM_D2 .RAM_D3 0x38000000 (NOLOAD): &#123; . = ALIGN(4); *(.RAM_D3) *(.RAM_D3*) . = ALIGN(4); &#125; AT &gt;RAM_D3 .LCD_RAM 0xC0000000 (NOLOAD): &#123; . = ALIGN(4); *(.LCD_RAM) *(.LCD_RAM*) . = ALIGN(4); &#125; AT &gt;LCD_RAM .EXTRAM 0xC01F4000 (NOLOAD): &#123; . = ALIGN(4); *(.EXTRAM) *(.EXTRAM*) . = ALIGN(4); &#125; AT &gt;EXTRAM .RAM_D1_TABLE 0x24064000 (NOLOAD): &#123; . = ALIGN(4); *(.RAM_D1_TABLE) *(.RAM_D1_TABLE*) . = ALIGN(4); &#125; AT &gt;RAM_D1_TABLE .RAM_D2_TABLE 0x3003C000 (NOLOAD): &#123; . = ALIGN(4); *(.RAM_D2_TABLE) *(.RAM_D2_TABLE*) . = ALIGN(4); &#125; AT &gt;RAM_D2_TABLE .RAM_D3_TABLE 0x3800F000 (NOLOAD): &#123; . = ALIGN(4); *(.RAM_D3_TABLE) *(.RAM_D3_TABLE*) . = ALIGN(4); &#125; AT &gt;RAM_D3_TABLE .EXTRAM_TABLE 0xC1E30000 (NOLOAD): &#123; . = ALIGN(4); *(.EXTRAM_TABLE) *(.EXTRAM_TABLE*) . = ALIGN(4); &#125; AT &gt;EXTRAM_TABLE&#125; 其中添加了LCD,外部SDRAM，以及内存管理表等的有关部分，在malloc.c中使用。123456LCD_RAM (RWX) : ORIGIN = 0xC0000000, LENGTH = 2MEXTRAM (RWX) : ORIGIN = 0xC01F4000, LENGTH = 28912KRAM_D1_TABLE (RWX) : ORIGIN = 0x24064000, LENGTH = 7KRAM_D2_TABLE (RWX) : ORIGIN = 0x3003C000, LENGTH = 1KRAM_D3_TABLE (RWX) : ORIGIN = 0x3800F000, LENGTH = 64KEXTRAM_TABLE (RWX) : ORIGIN = 0xC1E30000, LENGTH = 452K 以及在VS2017中开发，最好将malloc.c文件改名为mymalloc.c或者指定工程路径中的malloc.c避免IDE自动选择操作系统的malloc.c","categories":[{"name":"STM32","slug":"STM32","permalink":"http://yoursite.com/categories/STM32/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://yoursite.com/tags/STM32/"},{"name":"STM32内存管理","slug":"STM32内存管理","permalink":"http://yoursite.com/tags/STM32内存管理/"}]},{"title":"使用OpenOCD+DAPLINK时调试报错","slug":"用OpenOCD-DAPLINK时调试报错","date":"2020-08-13T19:34:00.000Z","updated":"2020-08-13T19:52:56.746Z","comments":true,"path":"2020/08/14/用OpenOCD-DAPLINK时调试报错/","link":"","permalink":"http://yoursite.com/2020/08/14/用OpenOCD-DAPLINK时调试报错/","excerpt":"","text":"环境：1、VS2017+VisualGDB2、OpenOCD+DAPLINK3、正点原子STM32H743开发板 使用OpenOCD+DAPLINK调试STM32H743IITx时出现如下报错：123456789101112131415Info : auto-selecting first available session transport &quot;swd&quot;. To override use &apos;transport select &lt;transport&gt;&apos;.Info : CMSIS-DAP: SWD SupportedInfo : CMSIS-DAP: FW Version = 0254Info : CMSIS-DAP: Serial# = 070000010669ff545648786687215624a5a5a5a597969908Info : CMSIS-DAP: Interface Initialised (SWD)Info : SWCLK/TCK = 1 SWDIO/TMS = 1 TDI = 0 TDO = 0 nTRST = 0 nRESET = 1Info : CMSIS-DAP: Interface readyInfo : clock speed 1800 kHzInfo : SWD DPIDR 0x6ba02477Info : stm32h7x.cpu0: hardware has 8 breakpoints, 4 watchpointsInfo : Listening on port 3333 for gdb connectionsInfo : AP write error, reset will not haltInfo : SWD DPIDR 0x6ba02477Error: timed out while waiting for target haltedTARGET: stm32h7x.cpu0 - Not halted 解决方法： 本人是在VisualGDB中使用的OpenOCD+DAPLINK进行调试，使用的配置文件为”target/stm32h7x.cfg”，所以修改文件及路径如下：1C:\\Users\\用户名\\AppData\\Local\\VisualGDB\\EmbeddedDebugPackages\\com.sysprogs.arm.openocd\\share\\openocd\\scripts\\target\\stm32h7x.cfg 用编辑器搜索reset发现126行左右，有如下：123456789101112131415# It is possible to access the DBGMCU component at 0xE00E1000 via AP2 instead# of the default AP0, and that works with SRST asserted; however, nonzero AP# usage does not work with HLA, so is not done by default. That change could be# made in a local configuration file if connect_assert_srst mode is needed for# a specific application and a non-HLA adapter is in use.reset_config srst_only srst_nogateif &#123;![using_hla]&#125; &#123; # if srst is not fitted use SYSRESETREQ to # perform a soft reset $_CHIPNAME.cpu0 cortex_m reset_config sysresetreq if &#123;[set $_CHIPNAME.DUAL_CORE]&#125; &#123; $_CHIPNAME.cpu1 cortex_m reset_config sysresetreq &#125; 将reset_config srst_only srst_nogate一行注释，并且添加$_CHIPNAME.cpu0 cortex_m reset_config sysresetreq修改为sysresetreq复位方式即可，修改完该段如下：1234567891011121314151617# It is possible to access the DBGMCU component at 0xE00E1000 via AP2 instead# of the default AP0, and that works with SRST asserted; however, nonzero AP# usage does not work with HLA, so is not done by default. That change could be# made in a local configuration file if connect_assert_srst mode is needed for# a specific application and a non-HLA adapter is in use.#reset_config srst_only srst_nogate$_CHIPNAME.cpu0 cortex_m reset_config sysresetreqif &#123;![using_hla]&#125; &#123; # if srst is not fitted use SYSRESETREQ to # perform a soft reset $_CHIPNAME.cpu0 cortex_m reset_config sysresetreq if &#123;[set $_CHIPNAME.DUAL_CORE]&#125; &#123; $_CHIPNAME.cpu1 cortex_m reset_config sysresetreq &#125; 问题解决了","categories":[{"name":"STM32","slug":"STM32","permalink":"http://yoursite.com/categories/STM32/"},{"name":"Debugger","slug":"STM32/Debugger","permalink":"http://yoursite.com/categories/STM32/Debugger/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://yoursite.com/tags/STM32/"},{"name":"DAPLINK","slug":"DAPLINK","permalink":"http://yoursite.com/tags/DAPLINK/"},{"name":"OpenOCD","slug":"OpenOCD","permalink":"http://yoursite.com/tags/OpenOCD/"}]},{"title":"STM32H743移植到IAR及使用DAPLINK调试配置","slug":"TM32H743移植IAR及使用DAPLINK调试配置","date":"2020-08-10T16:19:00.000Z","updated":"2020-08-16T15:52:41.607Z","comments":true,"path":"2020/08/11/TM32H743移植IAR及使用DAPLINK调试配置/","link":"","permalink":"http://yoursite.com/2020/08/11/TM32H743移植IAR及使用DAPLINK调试配置/","excerpt":"","text":"环境：1、正点原子APOLLO STM32H743开发板2、IAR for ARM 8.323、DAPLINK仿真器4、HAL库版本 STM32Cube_FW_H7_V1.6.0 本人平时用IAR不多，最近觉得它挺香的，于是打算准备一些基于IAR的stm32的模板。然后手头有DAPLINK，就决定是它作为debugger了，方便的功能香得鼻子都流血。由MDK移植到IAR的过程遇到一些问题，在这里记录一下大致的过程。 建立工程以及复制文件就不一一说明了，主要分两部分说几个地方： 1、文件不能全部由MDK的工程中拷贝过来，有些文件需要去官方HAL库的固件包中复制IAR环境需要的文件：1STM32Cube_FW_H7_V1.6.0\\Drivers\\CMSIS\\Device\\ST\\STM32H7xx\\Source\\Templates\\iar目录下的linker文件夹以及*.s文件 我为了以后方便其他型号的MCU使用，把上述目录的相关文件都拷贝了，如果不需要，可以只拷贝需要的型号。MDK和IAR都需要.s文件，只不过两者适用对象不同，所以要拷贝适用于当前环境的。然后特地需要拷贝的linker文件夹中，有若干个.icf文件，这个其实就是MDK环境下的.sct文件（链接器控制文件，也叫分散加载文件），主要描述MCU的FLASH以及RAM情况，外部的SRAM/SDRAM也可以在里面进行概述。 我在工程根目录下建立了startup文件夹用于存放这些文件，因为后面会修改并使用stm32h743xx_flash.icf这个文件，我将其从linker文件夹拷贝到了startup目录中。修改的目的是为了适配开发板，以及内存管理的文件，修改如下： 12345678910111213141516define memory mem with size = 4G;define region ROM_region = mem:[from __ICFEDIT_region_ROM_start__ to __ICFEDIT_region_ROM_end__];define region RAM_region = mem:[from __ICFEDIT_region_RAM_start__ to __ICFEDIT_region_RAM_end__];define region ITCMRAM_region = mem:[from __ICFEDIT_region_ITCMRAM_start__ to __ICFEDIT_region_ITCMRAM_end__];在下方添加define region AXI_RAM_region = mem:[from 0x24000000 to 0x2407FFFF];define region SRAM12_region = mem:[from 0x30000000 to 0x3003FFFF];define region SRAM3_region = mem:[from 0x30040000 to 0x30047FFF];define region SRAM4_region = mem:[from 0x38000000 to 0x3800FFFF];define region EXTRAM_region = mem:[from 0xC0000000 to 0xC1FFFFFF];place in AXI_RAM_region &#123;section .AXI_RAM&#125;;place in SRAM12_region &#123;section .SRAM12&#125;;place in SRAM3_region &#123;section .SRAM3&#125;;place in SRAM4_region &#123;section .SRAM4&#125;;place in EXTRAM_region &#123;section .EXTRAM&#125;; 在正点原子的例程中，原子哥有一个malloc.c文件，用于内存管理，我们也将其移植过来。修改如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#if defined(__CC_ARM) //MDK//内存池(64字节对齐)__align(64) u8 mem1base[MEM1_MAX_SIZE]; //内部SRAM内存池__align(64) u8 mem2base[MEM2_MAX_SIZE] __attribute__((at(0XC01F4000))); //外部SDRAM内存池,前面2M给LTDC用了(1280*800*2)__align(64) u8 mem3base[MEM3_MAX_SIZE] __attribute__((at(0x30000000))); //内部SRAM1+SRAM2内存池__align(64) u8 mem4base[MEM4_MAX_SIZE] __attribute__((at(0x38000000))); //内部SRAM4内存池//__align(64) u8 mem5base[MEM5_MAX_SIZE] __attribute__((at(0x20000000))); //内部DTCM内存池//__align(64) u8 mem6base[MEM6_MAX_SIZE] __attribute__((at(0x00000000))); //内部ITCM内存池 //内存管理表u32 mem1mapbase[MEM1_ALLOC_TABLE_SIZE]; //内部SRAM内存池MAPu32 mem2mapbase[MEM2_ALLOC_TABLE_SIZE] __attribute__((at(0XC01F4000+MEM2_MAX_SIZE))); //外部SDRAM内存池MAPu32 mem3mapbase[MEM3_ALLOC_TABLE_SIZE] __attribute__((at(0x30000000+MEM3_MAX_SIZE))); //内部SRAM1+SRAM2内存池MAPu32 mem4mapbase[MEM4_ALLOC_TABLE_SIZE] __attribute__((at(0x38000000+MEM4_MAX_SIZE))); //内部SRAM4内存池MAP//u32 mem5mapbase[MEM5_ALLOC_TABLE_SIZE] __attribute__((at(0x20000000+MEM5_MAX_SIZE))); //内部DTCM内存池MAP//u32 mem6mapbase[MEM6_ALLOC_TABLE_SIZE] __attribute__((at(0x00000000+MEM6_MAX_SIZE))); //内部ITCM内存池MAP #elif defined(__GNUC__) //GCC//内存池(64字节对齐)__attribute__((aligned(64))) u8 mem1base[MEM1_MAX_SIZE] __attribute__((section(&quot;.RAM_D1&quot;))); //内部SRAM内存池__attribute__((aligned(64))) u8 mem2base[MEM2_MAX_SIZE] __attribute__((section(&quot;.EXTRAM&quot;))); //外部SDRAM内存池,前面2M给LTDC用了(1280*800*2)__attribute__((aligned(64))) u8 mem3base[MEM3_MAX_SIZE] __attribute__((section(&quot;.RAM_D2&quot;))); //内部SRAM1+SRAM2内存池__attribute__((aligned(64))) u8 mem4base[MEM4_MAX_SIZE] __attribute__((section(&quot;.RAM_D3&quot;))); //内部SRAM4内存池//内存管理表u32 mem1mapbase[MEM1_ALLOC_TABLE_SIZE] __attribute__((section(&quot;.RAM_D1_TABLE&quot;))); //内部SRAM内存池MAPu32 mem2mapbase[MEM2_ALLOC_TABLE_SIZE] __attribute__((section(&quot;.EXTRAM_TABLE&quot;))); //外部SDRAM内存池MAPu32 mem3mapbase[MEM3_ALLOC_TABLE_SIZE] __attribute__((section(&quot;.RAM_D2_TABLE&quot;))); //内部SRAM1+SRAM2内存池MAPu32 mem4mapbase[MEM4_ALLOC_TABLE_SIZE] __attribute__((section(&quot;.RAM_D3_TABLE&quot;))); //内部SRAM4内存池MAP#elif defined(__ICCARM__) //IAR#pragma pack(64)#pragma location=&quot;.AXI_RAM&quot;__no_init u8 mem1base[MEM1_MAX_SIZE];#pragma location=0xC01F4000__no_init u8 mem2base[MEM2_MAX_SIZE];#pragma location=&quot;.SRAM12&quot;__no_init u8 mem3base[MEM3_MAX_SIZE];#pragma location=&quot;.SRAM4&quot;__no_init u8 mem4base[MEM4_MAX_SIZE];#pragma pack()#pragma location=(0x24000000+MEM1_MAX_SIZE)__no_init u32 mem1mapbase[MEM1_ALLOC_TABLE_SIZE]; #pragma location=(0xC01F4000+MEM2_MAX_SIZE)__no_init u32 mem2mapbase[MEM2_ALLOC_TABLE_SIZE]; #pragma location=(0x30000000+MEM3_MAX_SIZE)__no_init u32 mem3mapbase[MEM3_ALLOC_TABLE_SIZE]; #pragma location=(0x38000000+MEM4_MAX_SIZE)__no_init u32 mem4mapbase[MEM4_ALLOC_TABLE_SIZE];#endif 其中的 #pragma pack(64)以及#pragma location网上有详细功能描述及用法介绍，这里不再赘述了。并且其中的__no_init必须添加，否则无法正常使用，在调用my_mem_init()初始化内存池时会失败。 我添加了DSP库，在IAR中预处理宏定义：123456STM32H743xxUSE_HAL_DRIVER__ICCARM__ARM_MATH_CM7ARM_MATH_MATRIX_CHECKARM_MATH_ROUNDING 剩下就是一些日常遇到的error和warning了，我就不说了。 2、在使用DAPLINK的时候，按照一般设置，如下面一文中描述的设置：https://www.eemaker.com/daplink-iar.html我发现STM32H743IITx在只有官方的EVAL板，于是就添加了它，但是发现事情并没有这么简单，程序能下进去，但是它报错，并且不能调试，很难受。1error while calling macro execUserFlashExit 就是这个报错，google之，没发现解决方案，然后查询了IAR_EWARM_user_manual这本手册，以及了解了一波.board/.mac/.flash/.out文件的关系之后，进行了修改，不报错了，调试也正常。 据我了解到的，这些文件负责Flash-loader部分，.board/.flash文件应该都是脚本文件，.board用于指明不同的.flash文件来获取不同的地址映射，.flash用于描述地址映射、如何读写flash的二进制算法文件.out，.mac文件用于寄存器的一些初始化操作。 大致过程是，先调用.board文件，获取不同.flash的地址映射，使用对应的flash读写算法(.out文件)，同时获取.mac文件中要进行的初始化操作。各种信息收集全了之后，就进行flash的烧写了。 由于只有官方的EVAL板，所以通过查看这几个相关文件之间的调用关系，有如下操作：12345678910111213141516拷贝\\IAR Systems\\Embedded Workbench 8.2\\arm\\config\\flashloader\\ST目录下的FlashSTM32H7xx_STM32H743I-EVAL.boardFlashSTM32H7xxx.macFlashSTM32H753_BANK1.flashFlashSTM32H753_BANK2.flashFlashSTM32H7xxx_512kB.out5个文件到工程目录下新建的flashload文件夹中，并分别改名为FlashSTM32H7xx_STM32H743IIT6_APOLLO.boardFlashSTM32H7xxx_APOLLO.macFlashSTM32H743_BANK1_APOLLO.flashFlashSTM32H743_BANK2_APOLLO.flashFlashSTM32H7xxx_512kB.out 修改其中的调用关系，以及.mac文件中的execUserFlashExit()相关内容，这里就是报错的源头。 123456.mac文件中修改此处execUserFlashExit()&#123; __writeMemory32(0x05FA0004, 0xE000ED0C, &quot;Memory&quot;); //perform a soft reset&#125; 然后在IAR设置中选择好修改过的文件，进行调试。","categories":[{"name":"STM32","slug":"STM32","permalink":"http://yoursite.com/categories/STM32/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://yoursite.com/tags/STM32/"},{"name":"DAPLINK","slug":"DAPLINK","permalink":"http://yoursite.com/tags/DAPLINK/"},{"name":"IAR","slug":"IAR","permalink":"http://yoursite.com/tags/IAR/"}]},{"title":"RK3399内核编译以安装docker","slug":"RK3399内核编译以安装docker","date":"2019-10-15T19:14:00.000Z","updated":"2020-08-10T19:16:40.377Z","comments":true,"path":"2019/10/16/RK3399内核编译以安装docker/","link":"","permalink":"http://yoursite.com/2019/10/16/RK3399内核编译以安装docker/","excerpt":"","text":"环境：1、firefly-rk3399开发板2、ubuntu18.04 官方镜像3、内核版本 4.4.154 最近想使用Docker的某容器，在RK3399-firefly上安装的时候报错，具体安装过程就网上随意能搜到的，就不提及了。经过查看各种资料之后，成功安装docker，希望能帮到有需要的各位，也顺便记录一下。大致过程如下： 1、 查看docker的状态发现是failed，journalctl -fu docker 查看日志，有driver not support等字样，具体记不清了，这里大致了解了一下是因为docker有那么几种支持的storage-driver， 恰好内核又没打开任何一个支持的FS，所以只好去编译内核了。 2、修改配置进入linux-sdk/kernel目录下，获取https://raw.githubusercontent.com/docker/docker/master/contrib/check-config.sh脚本查看docker需要的设置是否打开，其他的都是enable，我仅放出storage-driver的配置，主要是要打开overlay的FS.123456789101112131415- Storage Drivers: - &quot;aufs&quot;: - CONFIG_AUFS_FS: missing - &quot;btrfs&quot;: - CONFIG_BTRFS_FS: missing - CONFIG_BTRFS_FS_POSIX_ACL: missing - &quot;devicemapper&quot;: - CONFIG_BLK_DEV_DM: enabled - CONFIG_DM_THIN_PROVISIONING: enabled - &quot;overlay&quot;: - CONFIG_OVERLAY_FS: enabled - &quot;zfs&quot;: - /dev/zfs: missing - zfs command: missing - zpool command: missing 3、之前的配置都是通过make menuconfig配置的，具体怎么操作网上找，挺多的。进入linux-sdk/kernel/目录，make ARCH=arm64 rk3399-firefly-linux.img -j8 编译生成boot.img后烧录到开发板。上电发现docker仍报错，修改配置文件内容（没有就新建），/etc/docker/daemon.json， 内容如下：1234&#123; &quot;registry-mirrors&quot;: [&quot;aliyun加速地址&quot;], &quot;storage-driver&quot;: &quot;overlay&quot;&#125; 上面的阿里云加速地址换成自己的，这里主要是为了pull容器的时候舒服一点，教程可以在网上搜到很多，保存。重启服务：systemctl daemon-reload &amp;&amp; systemctl restart docker还是无法正常运行，继续查看日志，发现报错已经变更了，这时候提示的是iptables does not exist 等字样的信息，其实就是说iptables内核模块没有，配置完编译新内核上传。加入以下模块，基本都在networking support-&gt;networking options中，我也记不太清了，各位自己查找一下吧。。。。 Netfilter connection tracking supportNetbios name service protocal support(new)Netfilter Xtables support (required for ip_tables) IP: Netfilter ConfigurationIPv4 connection tracking support (require for NAT)IP tables support (required for filtering/masq/NAT) 什么 NAT的选项，忘了MASQUERADE target supportREDIRECT target support 按上面步骤重新编译并烧录到开发板，这次上电，docker绿了，开心。操作了一下，正常1234sudo docker run ubuntu:18.04 /bin/echo &quot;Hello world&quot;Status: Downloaded newer image for ubuntu:18.04 Hello world","categories":[{"name":"ARM_Linux","slug":"ARM-Linux","permalink":"http://yoursite.com/categories/ARM-Linux/"}],"tags":[]},{"title":"ARM处理器内部寄存器","slug":"ARM内部处理寄存器","date":"2019-10-13T23:26:11.000Z","updated":"2020-08-10T19:18:13.398Z","comments":true,"path":"2019/10/14/ARM内部处理寄存器/","link":"","permalink":"http://yoursite.com/2019/10/14/ARM内部处理寄存器/","excerpt":"","text":"ARM处理器内部寄存器作用 r0-r15 and R0-R15a1-a4 (argument, result, or scratch registers, synonyms for r0 to r3)v1-v8 (variable registers, r4 to r11)sb and SB (static base, r9)ip and IP (intra-procedure-call scratch register, r12)sp and SP (stack pointer, r13)lr and LR (link register, r14)pc and PC (program counter, r15) r0-r3用作传入函数参数，传出函数返回值。在子程序调用之间，可以将 r0-r3 用于任何用途。被调用函数在返回之前不必恢复 r0-r3。如果调用函数需要再次使用 r0-r3 的内容，则它必须保留这些内容。 r4-r11被用来存放函数的局部变量。如果被调用函数使用了这些寄存器，它在返回之前必须恢复这些寄存器的值。 r12是内部调用暂时寄存器 ip。它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色。在过程调用之间，可以将它用于任何用途。被调用函数在返回之前不必恢复 r12。 r13是栈指针 sp。它不能用于任何其它用途。sp 中存放的值在退出被调用函数时必须与进入时的值相同。 r14是链接寄存器 lr。如果您保存了返回地址，则可以在调用之间将 r14 用于其它用途，程序返回时要恢复。 r15是程序计数器 PC。它不能用于任何其它用途。 注意：在中断程序中，所有的寄存器都必须保护，编译器会自动保护R4～R11原文出处：https://blog.csdn.net/wh8_2011/article/details/53195320https://blog.csdn.net/Decisiveness/article/details/44106197","categories":[],"tags":[]},{"title":"Use GCC to build STM32 projects","slug":"Use-GCC-to-build-STM32-projects","date":"2019-02-01T07:31:00.000Z","updated":"2019-10-16T18:18:02.474Z","comments":true,"path":"2019/02/01/Use-GCC-to-build-STM32-projects/","link":"","permalink":"http://yoursite.com/2019/02/01/Use-GCC-to-build-STM32-projects/","excerpt":"","text":"最近突然想建立一个利用makefile编译的STM32工程模板，记录一下辛酸的过程。。。 其实Makefile虽然我不是很熟，但是写一个简单的makefile还是OK的，所以在makefile阶段并没有遇到什么奇怪的问题，注意好makefile的规则就排除了，比如有时候没注意看TAB之类的，然后就是文件的路径。 在make的过程中出现以下报错信息。 12345/tmp/cc6kleCZ.s: Assembler messages:/tmp/cc6kleCZ.s:488: Error: registers may not be the same -- `strexb r0,r0,[r1]&apos;/tmp/cc6kleCZ.s:512: Error: registers may not be the same -- `strexh r0,r0,[r1]&apos;makefile:60: recipe for target &apos;core/CM3/core_cm3.o&apos; failedmake: *** [core/CM3/core_cm3.o] Error 1 作为一个菜鸡，看到Assembler 之类的error是比较慌的，但是还是不能畏惧的，正面刚。打开了core_cm3.c，找到了与它相关的函数，google后发现github上有人解决了，于是看了一下分析，做出了修改。然后成功编译过这一步。 12345678910 uint32_t __STREXB(uint8_t value, uint8_t *addr)&#123; uint32_t result=0; //__ASM volatile (&quot;strexb %0, %2, [%1]&quot; : &quot;=r&quot; (result) : &quot;r&quot; (addr), &quot;r&quot; (value) ); __ASM volatile (&quot;strexb %0, %2, [%1]&quot; : &quot;=&amp;r&quot; (result) : &quot;r&quot; (addr), &quot;r&quot; (value) ); return(result);&#125; 12345678910 uint32_t __STREXH(uint16_t value, uint16_t *addr)&#123; uint32_t result=0; //__ASM volatile (&quot;strexh %0, %2, [%1]&quot; : &quot;=r&quot; (result) : &quot;r&quot; (addr), &quot;r&quot; (value) ); __ASM volatile (&quot;strexh %0, %2, [%1]&quot; : &quot;=&amp;r&quot; (result) : &quot;r&quot; (addr), &quot;r&quot; (value) ); return(result);&#125; 然后还有一个问题就是GCC编译一个文件时出现 12 error: expected &apos;(&apos; before &apos;void&apos;__asm void MSR_MSP(u32 addr) 之类的报错，这个打开源文件后发现其实是GCC在C语言内嵌汇编需要注意的一个地方，修改为如下即可。 123456 void MSR_MSP(u32 addr)&#123; __ASM volatile(&quot;MSR MSP, r0&quot;); __ASM volatile(&quot;BX r14&quot;); &#125; 还有要注意的就是，在stm32 标准固件库内，CORE的startup中有多个文件夹，Keil使用的启动文件在arm文件夹内，这和使用GCC时是不一样的，GCC下应该使用gcc_ride7中的启动文件,TrueSTUDIO是官方的IDE软件，其使用的也是GCC所以也可以使用其中的。然后就是链接文件(.ld)，可以使用stm32标准固件库文件夹下/Project/STM32F10x_StdPeriph_Template/TrueSTUDIO/中的链接文件。 然后成功make出了 hex bin elf等文件，download到stm32后也是正常的。","categories":[],"tags":[]},{"title":"Hello World","slug":"Hello-World","date":"2019-01-01T02:22:00.000Z","updated":"2019-10-16T18:18:02.472Z","comments":true,"path":"2019/01/01/Hello-World/","link":"","permalink":"http://yoursite.com/2019/01/01/Hello-World/","excerpt":"","text":"Hello World1$ Hello World","categories":[],"tags":[]}]}